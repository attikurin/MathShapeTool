<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®—æ•°ãƒ»æ•°å­¦ å›³å½¢ä½œæˆãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f3f4f6;
        }
        canvas {
            background-image: 
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º */
            background-color: white;
            cursor: crosshair; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¼ã‚½ãƒ«å¤‰æ›´ */
            touch-action: none;
        }
        /* ã‚°ãƒªãƒƒãƒ‰éè¡¨ç¤ºæ™‚ã®ã‚¯ãƒ©ã‚¹ */
        canvas.no-grid {
            background-image: none;
        }
        .input-group {
            margin-bottom: 0.75rem;
        }
        .input-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.25rem;
        }
        .input-field {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            transition: border-color 0.15s ease-in-out;
        }
        .input-field:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8; 
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 px-6 py-3 flex justify-between items-center shadow-sm z-10">
        <div class="flex items-center gap-4">
            <!-- ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ -->
            <button onclick="toggleHelp()" class="p-2 rounded-lg hover:bg-gray-100 text-gray-600 focus:outline-none transition" title="ä½¿ã„æ–¹ã‚’è¦‹ã‚‹">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 text-white p-1.5 rounded-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm5.414 0a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243z" />
                    </svg>
                </div>
                <h1 class="text-xl font-bold text-gray-800">ç®—æ•°ãƒ»æ•°å­¦ å›³å½¢ä½œæˆãƒ„ãƒ¼ãƒ«</h1>
            </div>
        </div>
        <button onclick="downloadImage()" class="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium transition shadow-sm">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
            <span>ç”»åƒä¿å­˜ (PNG)</span>
        </button>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Sidebar Controls -->
        <aside class="w-80 bg-white border-r border-gray-200 overflow-y-auto flex flex-col shadow-[4px_0_24px_rgba(0,0,0,0.02)] z-0">
            <div class="p-5 space-y-6">
                
                <!-- å›³å½¢é¸æŠ -->
                <div>
                    <label class="input-label">å›³å½¢ã®ç¨®é¡</label>
                    <select id="shapeType" class="input-field bg-gray-50 font-medium" onchange="updateUI()">
                        <option value="triangle">ä¸‰è§’å½¢ (3è¾ºã®é•·ã•)</option>
                        <option value="triangleSAS">ä¸‰è§’å½¢ (2è¾ºã¨ãã®é–“ã®è§’)</option>
                        <option value="rectangle">é•·æ–¹å½¢ãƒ»æ­£æ–¹å½¢</option>
                        <option value="parallelogram">å¹³è¡Œå››è¾ºå½¢</option>
                        <option value="circle">å††</option>
                        <option value="angle">è§’åº¦ãƒ»è§’ã®å¤§ãã•</option>
                        <option value="coords">å¤šè§’å½¢ (åº§æ¨™æŒ‡å®š)</option>
                    </select>
                </div>

                <hr class="border-gray-100">

                <!-- å‹•çš„å…¥åŠ›ã‚¨ãƒªã‚¢ -->
                <div id="dynamicInputs" class="space-y-4"></div>

                <hr class="border-gray-100">

                <!-- è¡¨ç¤ºè¨­å®š -->
                <div>
                    <h3 class="text-sm font-bold text-gray-900 mb-3 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                        è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
                    </h3>
                    
                    <div class="grid grid-cols-2 gap-3 mb-3">
                        <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                            <input type="checkbox" id="showGrid" checked onchange="updateCanvas()" class="rounded text-blue-600 focus:ring-blue-500">
                            æ–¹çœ¼ç´™è¡¨ç¤º
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                            <input type="checkbox" id="showVertices" checked onchange="updateCanvas()" class="rounded text-blue-600 focus:ring-blue-500">
                            é ‚ç‚¹å (A,B..)
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                            <input type="checkbox" id="showLengths" onchange="updateCanvas()" class="rounded text-blue-600 focus:ring-blue-500">
                            è¾ºã®é•·ã•
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                            <input type="checkbox" id="showAngles" onchange="updateCanvas()" class="rounded text-blue-600 focus:ring-blue-500">
                            è§’åº¦ãƒãƒ¼ã‚¯
                        </label>
                    </div>

                    <div class="grid grid-cols-2 gap-3">
                         <div class="input-group">
                            <label class="input-label">ç·šã®å¤ªã•</label>
                            <input type="number" id="strokeWidth" value="2" min="1" max="10" class="input-field" onchange="updateCanvas()">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æ–‡å­—ã‚µã‚¤ã‚º</label>
                            <input type="number" id="fontSize" value="16" min="8" max="48" class="input-field" onchange="updateCanvas()">
                        </div>
                    </div>
                </div>

                <div class="text-xs text-gray-500 mt-auto pt-4 border-t border-gray-100">
                    <p class="mb-1">ğŸ’¡ ãƒ’ãƒ³ãƒˆ:</p>
                    <ul class="list-disc list-inside space-y-1">
                        <li>ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä½™ç™½ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼šç§»å‹•</li>
                        <li><span class="font-bold text-blue-600">é ‚ç‚¹ï¼ˆâ—ï¼‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼šå¤‰å½¢</span></li>
                    </ul>
                </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="flex-1 bg-gray-100 relative overflow-hidden flex items-center justify-center p-4">
            <div class="shadow-lg border border-gray-200 bg-white relative">
                 <!-- Canvas -->
                <canvas id="mainCanvas" width="800" height="600"></canvas>
                
                <!-- Reset Position Button -->
                <button onclick="resetView()" class="absolute bottom-4 right-4 bg-white border border-gray-300 shadow-sm p-2 rounded-full hover:bg-gray-50 text-gray-600" title="ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                    </svg>
                </button>
            </div>
        </main>
    </div>

    <!-- Help Modal (ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰) -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4 transition-opacity">
        <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Modal Header -->
            <div class="p-5 border-b border-gray-100 flex justify-between items-center bg-gray-50">
                <div class="flex items-center gap-2">
                    <div class="bg-blue-100 text-blue-600 p-2 rounded-lg">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰</h2>
                </div>
                <button onclick="toggleHelp()" class="text-gray-400 hover:text-gray-600 p-2 rounded-full hover:bg-gray-200 transition">
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>

            <!-- Modal Content -->
            <div class="p-6 overflow-y-auto space-y-8">
                
                <!-- Section 1 -->
                <div class="flex gap-4">
                    <div class="flex-shrink-0 w-8 h-8 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold">1</div>
                    <div>
                        <h3 class="font-bold text-lg text-gray-900 mb-2">å›³å½¢ã‚’ä½œã‚‹</h3>
                        <p class="text-gray-600 leading-relaxed mb-3">
                            ç”»é¢å·¦å´ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã€ä½œã‚ŠãŸã„å›³å½¢ï¼ˆä¸‰è§’å½¢ã‚„å††ãªã©ï¼‰ã‚’é¸ã³ã¾ã™ã€‚<br>
                            ä¸‹ã®æ•°å­—ã‚’å¤‰ãˆã‚‹ã¨ã€ã™ãã«å½¢ãŒå¤‰ã‚ã‚Šã¾ã™ã€‚
                        </p>
                        <div class="bg-blue-50 p-3 rounded-lg border border-blue-100 text-sm text-blue-800">
                            <strong>ãƒ’ãƒ³ãƒˆï¼š</strong> æ­£ç¢ºãªå›³å½¢ãŒè‡ªå‹•ã§æã‹ã‚Œã‚‹ã®ã§ã€å®šè¦ã‚„ã‚³ãƒ³ãƒ‘ã‚¹ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚
                        </div>
                    </div>
                </div>

                <!-- Section 2 -->
                <div class="flex gap-4">
                    <div class="flex-shrink-0 w-8 h-8 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold">2</div>
                    <div>
                        <h3 class="font-bold text-lg text-gray-900 mb-2">è¦‹ãŸç›®ã‚’æ•´ãˆã‚‹ãƒ»å¤‰å½¢ã™ã‚‹</h3>
                        <p class="text-gray-600 leading-relaxed">
                            <strong>é ‚ç‚¹ï¼ˆè§’ã®ä¸¸ã„ç‚¹ï¼‰ã‚’ãƒã‚¦ã‚¹ã§ãƒ‰ãƒ©ãƒƒã‚°</strong>ã™ã‚‹ã¨ã€å½¢ã‚’è‡ªç”±ã«å¤‰ãˆã‚‰ã‚Œã¾ã™ã€‚<br>
                            å¤‰å½¢ã«åˆã‚ã›ã¦ã€å·¦å´ã®æ•°å€¤ã‚‚è‡ªå‹•çš„ã«æ›´æ–°ã•ã‚Œã¾ã™ã€‚<br>
                            ã¾ãŸã€ã€Œæ–¹çœ¼ç´™è¡¨ç¤ºã€ã‚„ã€Œé ‚ç‚¹åã€ãªã©ã®è¡¨ç¤º/éè¡¨ç¤ºã‚‚åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚
                        </p>
                    </div>
                </div>

                <!-- Section 3 -->
                <div class="flex gap-4">
                    <div class="flex-shrink-0 w-8 h-8 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold">3</div>
                    <div>
                        <h3 class="font-bold text-lg text-gray-900 mb-2">ç”»åƒã‚’ä¿å­˜ã™ã‚‹</h3>
                        <p class="text-gray-600 leading-relaxed mb-3">
                            å³ä¸Šã®<strong>ã€Œç”»åƒä¿å­˜ (PNG)ã€</strong>ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ãƒ‘ã‚½ã‚³ãƒ³ã«ç”»åƒã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã™ã€‚
                        </p>
                        <ul class="list-disc list-inside text-gray-600 space-y-1 bg-gray-50 p-3 rounded-lg">
                            <li>èƒŒæ™¯ãŒé€æ˜ãªã®ã§ã€Wordã‚„PowerPointã«ãã‚Œã„ã«è²¼ã‚Šä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚</li>
                            <li>æ–¹çœ¼ç´™ã®ãƒã‚¹ç›®ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ï¼ˆå›³å½¢ã ã‘ä¿å­˜ã•ã‚Œã¾ã™ï¼‰ã€‚</li>
                        </ul>
                    </div>
                </div>

            </div>

            <!-- Modal Footer -->
            <div class="p-4 border-t border-gray-100 bg-gray-50 flex justify-center rounded-b-xl">
                <button onclick="toggleHelp()" class="bg-blue-600 text-white px-8 py-2.5 rounded-lg hover:bg-blue-700 font-medium transition shadow-sm">
                    é–‰ã˜ã‚‹
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let currentShape = 'triangle';
        let offset = { x: 400, y: 300 }; // Center of canvas
        let currentPoints = []; // Stores displayed points {x, y, label} (relative to offset)
        
        // Interaction State
        let isDragging = false;
        let isDraggingVertex = false;
        let draggingVertexIndex = -1;
        let dragStart = { x: 0, y: 0 };
        
        // Scale unit (1 unit input = how many pixels)
        const PIXEL_SCALE = 20;
        const HIT_RADIUS = 15; // Radius to detect click on vertex

        // Help Modal Logic
        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            modal.classList.toggle('hidden');
        }

        document.getElementById('helpModal').addEventListener('click', function(e) {
            if (e.target === this) {
                toggleHelp();
            }
        });

        // UI Update Logic
        function updateUI() {
            const type = document.getElementById('shapeType').value;
            const container = document.getElementById('dynamicInputs');
            
            // Rebuild inputs if shape type changed OR if container is empty (first run)
            // Note: Removed comments from HTML container to make this check robust
            if (currentShape !== type || container.children.length === 0) {
                container.innerHTML = '';
                currentShape = type;
                
                const createInput = (id, label, value, type='number', step='0.1') => {
                    return `
                        <div class="input-group">
                            <label class="input-label">${label}</label>
                            <input type="${type}" id="${id}" value="${value}" step="${step}" class="input-field" oninput="updateCanvas()">
                        </div>
                    `;
                };

                if (type === 'triangle') {
                    container.innerHTML += `<div class="grid grid-cols-3 gap-2">
                        ${createInput('sideA', 'è¾º A', 6)}
                        ${createInput('sideB', 'è¾º B', 5)}
                        ${createInput('sideC', 'è¾º C', 4)}
                    </div>`;
                    container.innerHTML += `<div class="text-xs text-amber-600 mt-1" id="triangleWarning" style="display:none">âš ï¸ ä¸‰è§’å½¢ãŒæˆç«‹ã—ã¾ã›ã‚“</div>`;
                } else if (type === 'triangleSAS') {
                     container.innerHTML += `
                        <div class="grid grid-cols-2 gap-2">
                            ${createInput('sasSideA', 'è¾º A', 6)}
                            ${createInput('sasSideB', 'è¾º B', 5)}
                        </div>
                        ${createInput('sasAngle', 'é–“ã®è§’ (Â°)', 60)}
                    `;
                } else if (type === 'rectangle') {
                    container.innerHTML += `
                        <div class="grid grid-cols-2 gap-2">
                            ${createInput('rectW', 'æ¨ªå¹…', 8)}
                            ${createInput('rectH', 'é«˜ã•', 5)}
                        </div>
                    `;
                } else if (type === 'parallelogram') {
                    container.innerHTML += `
                        <div class="grid grid-cols-2 gap-2">
                            ${createInput('paraBase', 'åº•è¾º', 8)}
                            ${createInput('paraSide', 'æ–œè¾º', 5)}
                        </div>
                        ${createInput('paraAngle', 'å·¦ä¸‹ã®è§’åº¦ (Â°)', 60)}
                    `;
                } else if (type === 'circle') {
                    container.innerHTML += createInput('circleR', 'åŠå¾„', 5);
                } else if (type === 'angle') {
                    container.innerHTML += `
                         <div class="grid grid-cols-2 gap-2">
                            ${createInput('angleSize', 'è§’åº¦ (Â°)', 45)}
                            ${createInput('angleLen', 'ç·šã®é•·ã•', 6)}
                         </div>
                    `;
                } else if (type === 'coords') {
                    container.innerHTML += `
                        <div class="input-group">
                            <label class="input-label">åº§æ¨™ (x, y) 1è¡Œã«1ç‚¹</label>
                            <textarea id="coordInput" class="input-field h-32 font-mono" oninput="updateCanvas()">0, 0
5, 0
3, 4</textarea>
                        </div>
                    `;
                }
            }

            updateCanvas();
        }

        // Draw Logic
        function updateCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const showGridEl = document.getElementById('showGrid');
            if (!showGridEl) return; // Safety check
            
            const showGrid = showGridEl.checked;
            canvas.classList.toggle('no-grid', !showGrid);

            // Settings
            ctx.lineWidth = document.getElementById('strokeWidth')?.value || 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#000000';
            ctx.font = `${document.getElementById('fontSize')?.value || 16}px 'Noto Sans JP'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const showVertices = document.getElementById('showVertices')?.checked;
            const showLengths = document.getElementById('showLengths')?.checked;
            const showAngles = document.getElementById('showAngles')?.checked;

            let points = [];
            let isValid = true;
            const labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            
            // Safety Helper for Input Retrieval
            const getVal = (id) => {
                const el = document.getElementById(id);
                return el ? parseFloat(el.value) : NaN;
            };

            try {
                if (currentShape === 'triangle') {
                    const a = getVal('sideA') * PIXEL_SCALE;
                    const b = getVal('sideB') * PIXEL_SCALE;
                    const c = getVal('sideC') * PIXEL_SCALE;

                    if (isNaN(a) || isNaN(b) || isNaN(c)) return;

                    if (a + b <= c || a + c <= b || b + c <= a) {
                        const warn = document.getElementById('triangleWarning');
                        if(warn) warn.style.display = 'block';
                        isValid = false;
                    } else {
                        const warn = document.getElementById('triangleWarning');
                        if(warn) warn.style.display = 'none';
                        const cosA = (b*b + c*c - a*a) / (2*b*c);
                        const angleA = Math.acos(cosA);
                        const Cx = b * Math.cos(angleA);
                        const Cy = -b * Math.sin(angleA); 

                        const centerX = (0 + c + Cx) / 3;
                        const centerY = (0 + 0 + Cy) / 3;

                        points = [
                            {x: 0 - centerX, y: 0 - centerY, label: 'A'},
                            {x: c - centerX, y: 0 - centerY, label: 'B'},
                            {x: Cx - centerX, y: Cy - centerY, label: 'C'}
                        ];
                    }

                } else if (currentShape === 'triangleSAS') {
                    const b = getVal('sasSideA') * PIXEL_SCALE;
                    const c = getVal('sasSideB') * PIXEL_SCALE;
                    const ang = getVal('sasAngle') * (Math.PI / 180);
                    
                    if (isNaN(b) || isNaN(c) || isNaN(ang)) return;

                    const Bx = c;
                    const By = 0;
                    const Cx = b * Math.cos(ang);
                    const Cy = -b * Math.sin(ang);

                    const centerX = (0 + Bx + Cx) / 3;
                    const centerY = (0 + By + Cy) / 3;

                     points = [
                        {x: 0 - centerX, y: 0 - centerY, label: 'A'},
                        {x: Bx - centerX, y: By - centerY, label: 'B'},
                        {x: Cx - centerX, y: Cy - centerY, label: 'C'}
                    ];

                } else if (currentShape === 'rectangle') {
                    const w = getVal('rectW') * PIXEL_SCALE;
                    const h = getVal('rectH') * PIXEL_SCALE;
                    if (isNaN(w) || isNaN(h)) return;

                    const hw = w/2;
                    const hh = h/2;
                    points = [
                        {x: -hw, y: hh, label: 'A'}, {x: hw, y: hh, label: 'B'},
                        {x: hw, y: -hh, label: 'C'}, {x: -hw, y: -hh, label: 'D'}
                    ];

                } else if (currentShape === 'parallelogram') {
                    const base = getVal('paraBase') * PIXEL_SCALE;
                    const side = getVal('paraSide') * PIXEL_SCALE;
                    const ang = getVal('paraAngle') * (Math.PI / 180);
                    if (isNaN(base) || isNaN(side) || isNaN(ang)) return;

                    const h = side * Math.sin(ang);
                    const offsetX = side * Math.cos(ang);
                    const pA = {x: 0, y: 0};
                    const pC = {x: base + offsetX, y: -h};
                    const midX = (pA.x + pC.x)/2;
                    const midY = (pA.y + pC.y)/2;

                    points = [
                        {x: 0 - midX, y: 0 - midY, label: 'A'},
                        {x: base - midX, y: 0 - midY, label: 'B'},
                        {x: (base + offsetX) - midX, y: -h - midY, label: 'C'},
                        {x: offsetX - midX, y: -h - midY, label: 'D'}
                    ];

                } else if (currentShape === 'circle') {
                    const valR = getVal('circleR');
                    if (isNaN(valR)) return;

                    const r = valR * PIXEL_SCALE;
                    points = [{x:0, y:0, label:'O'}]; 
                    // Draw here directly
                    ctx.save();
                    ctx.translate(offset.x, offset.y);
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, 2 * Math.PI);
                    ctx.stroke();
                    if(showVertices) {
                         ctx.fillStyle = 'blue';
                         ctx.fillStyle = 'black';
                         ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
                         drawText('O', 0, 0);
                         
                         // Add a handle on the perimeter for dragging radius
                         ctx.beginPath(); ctx.arc(r, 0, 5, 0, Math.PI*2); ctx.fillStyle='#3b82f6'; ctx.fill();
                    }
                    if(showLengths) {
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(r, 0);
                        ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
                        drawText(valR.toString(), r/2, -15);
                    }
                    ctx.restore();
                    // Circle is special, add radius point for hit detection
                    points.push({x: r, y: 0, label: 'R_Handle'});
                    currentPoints = points; // Save for logic
                    return; // Skip polygon drawing

                } else if (currentShape === 'angle') {
                    const len = getVal('angleLen') * PIXEL_SCALE;
                    const deg = getVal('angleSize');
                    if (isNaN(len) || isNaN(deg)) return;

                    const rad = deg * (Math.PI / 180);
                    points = [
                        {x: len, y: 0, label: 'A'},
                        {x: 0, y: 0, label: 'O'},
                        {x: len * Math.cos(-rad), y: len * Math.sin(-rad), label: 'B'}
                    ];
                } else if (currentShape === 'coords') {
                    const inputEl = document.getElementById('coordInput');
                    if (!inputEl) return;
                    
                    const raw = inputEl.value.trim().split('\n');
                    let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
                    const tempPoints = raw.map((line, i) => {
                        const [x, y] = line.split(',').map(n => parseFloat(n) * PIXEL_SCALE);
                        if (isNaN(x) || isNaN(y)) return null;
                        const screenY = -y; 
                        if(x < xMin) xMin = x; if(x > xMax) xMax = x;
                        if(screenY < yMin) yMin = screenY; if(screenY > yMax) yMax = screenY;
                        return {x: x, y: screenY, label: labels[i] || `P${i}`};
                    }).filter(p => p !== null);

                    const cx = (xMin + xMax) / 2;
                    const cy = (yMin + yMax) / 2;
                    points = tempPoints.map(p => ({ x: p.x - cx, y: p.y - cy, label: p.label }));
                }

                // Generic Draw
                currentPoints = points; // Save for hit detection
                if (isValid && points.length > 0) {
                    ctx.save();
                    ctx.translate(offset.x, offset.y);

                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    if (currentShape !== 'angle') ctx.closePath();
                    ctx.stroke();

                    // Labels, Vertices, Lengths
                    points.forEach((p, i) => {
                        if (showVertices) {
                            const extension = 20;
                            const dist = Math.sqrt(p.x*p.x + p.y*p.y);
                            const dirX = dist === 0 ? 0 : p.x / dist;
                            const dirY = dist === 0 ? 0 : p.y / dist;
                            
                            drawText(p.label, p.x + dirX*extension, p.y + dirY*extension);
                            
                            // Draw vertex dot (highlight if hover/drag?)
                            ctx.fillStyle = '#3b82f6'; // Blue for interactive hint
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        if (showLengths && i < points.length && (currentShape !== 'angle' || i < points.length -1)) {
                            let nextIndex = (i + 1) % points.length;
                            if (currentShape === 'angle' && i === points.length -1) return;
                            if (currentShape === 'angle' && i === 1) return; 

                            const pNext = points[nextIndex];
                            const midX = (p.x + pNext.x) / 2;
                            const midY = (p.y + pNext.y) / 2;
                            const dx = pNext.x - p.x;
                            const dy = pNext.y - p.y;
                            const pixelLen = Math.sqrt(dx*dx + dy*dy);
                            const val = Math.round((pixelLen / PIXEL_SCALE) * 10) / 10;
                            
                            let nx = -dy; let ny = dx;
                            const len = Math.sqrt(nx*nx + ny*ny);
                            nx /= len; ny /= len;
                            if (midX*nx + midY*ny < 0) { nx = -nx; ny = -ny; }
                            drawText(val.toString(), midX + nx*15, midY + ny*15);
                        }
                    });

                    // Angle Arcs
                    if (showAngles && (['triangle','triangleSAS','angle','parallelogram'].includes(currentShape))) {
                        points.forEach((p, i) => {
                             const prev = points[(i - 1 + points.length) % points.length];
                             const next = points[(i + 1) % points.length];
                             if(currentShape === 'angle' && i !== 1) return; 

                             const a1 = Math.atan2(prev.y - p.y, prev.x - p.x);
                             const a2 = Math.atan2(next.y - p.y, next.x - p.x);
                             ctx.beginPath();
                             ctx.arc(p.x, p.y, 20, a1, a2, a2 < a1);
                             ctx.stroke();
                        });
                    }
                    ctx.restore();
                }
            } catch (e) {
                console.error("Drawing error:", e);
            }
        }

        function drawText(text, x, y) {
            ctx.fillStyle = '#000000';
            ctx.fillText(text, x, y);
        }

        // --- Interaction Logic ---

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        // Mousedown
        canvas.addEventListener('mousedown', e => {
            const pos = getMousePos(e);
            
            // Check for vertex hit
            let hitIndex = -1;
            // Check in reverse order so top elements are clicked first
            for (let i = currentPoints.length - 1; i >= 0; i--) {
                const p = currentPoints[i];
                // Points are stored relative to offset. Convert to screen.
                const screenX = p.x + offset.x;
                const screenY = p.y + offset.y;
                const dx = pos.x - screenX;
                const dy = pos.y - screenY;
                if (dx*dx + dy*dy < HIT_RADIUS*HIT_RADIUS) {
                    hitIndex = i;
                    break;
                }
            }

            if (hitIndex !== -1) {
                isDraggingVertex = true;
                draggingVertexIndex = hitIndex;
                isDragging = true; // Block pan
            } else {
                isDragging = true;
                isDraggingVertex = false;
                dragStart = pos;
            }
        });

        // Mousemove
        window.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            
            // Cursor Hover Effect
            if (!isDraggingVertex && !isDragging) {
                let hover = false;
                for (let i = 0; i < currentPoints.length; i++) {
                    const p = currentPoints[i];
                    const screenX = p.x + offset.x;
                    const screenY = p.y + offset.y;
                    const dx = pos.x - screenX;
                    const dy = pos.y - screenY;
                    if (dx*dx + dy*dy < HIT_RADIUS*HIT_RADIUS) {
                        hover = true;
                        break;
                    }
                }
                canvas.style.cursor = hover ? 'pointer' : 'move';
            }

            if (isDraggingVertex && currentPoints[draggingVertexIndex]) {
                // Determine mouse pos relative to Shape Center (offset)
                const mouseRelX = pos.x - offset.x;
                const mouseRelY = pos.y - offset.y;
                
                // Helper to update input value
                const setVal = (id, val) => {
                    const el = document.getElementById(id);
                    if(el) el.value = Math.round(val * 10) / 10;
                };

                // Logic per shape
                if (currentShape === 'triangle') {
                    // Update current point in temp array to calc distances
                    const newPts = [...currentPoints];
                    newPts[draggingVertexIndex] = { x: mouseRelX, y: mouseRelY };
                    
                    // Indices: A=0, B=1, C=2
                    // Side A = dist(B,C)
                    // Side B = dist(A,C)
                    // Side C = dist(A,B)
                    const dist = (p1, p2) => Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2) / PIXEL_SCALE;
                    
                    setVal('sideA', dist(newPts[1], newPts[2]));
                    setVal('sideB', dist(newPts[0], newPts[2]));
                    setVal('sideC', dist(newPts[0], newPts[1]));
                
                } else if (currentShape === 'triangleSAS') {
                    // Points: A=0(origin), B=1(on axis), C=2(angled)
                    // Drag A: Move whole shape? For now, ignore or just pan.
                    // Drag B: Update Side B (dist A-B).
                    // Drag C: Update Side A (dist A-C) and Angle.
                    
                    if (draggingVertexIndex === 1) { // B
                        const d = Math.sqrt(mouseRelX*mouseRelX + mouseRelY*mouseRelY) / PIXEL_SCALE;
                        setVal('sasSideB', d);
                    } else if (draggingVertexIndex === 2) { // C
                        const d = Math.sqrt(mouseRelX*mouseRelX + mouseRelY*mouseRelY) / PIXEL_SCALE;
                        let deg = Math.atan2(-mouseRelY, mouseRelX) * (180/Math.PI);
                        if(deg < 0) deg += 360;
                        setVal('sasSideA', d);
                        setVal('sasAngle', deg);
                    }

                } else if (currentShape === 'rectangle') {
                    // Symmetric resize
                    const w = Math.abs(mouseRelX) * 2 / PIXEL_SCALE;
                    const h = Math.abs(mouseRelY) * 2 / PIXEL_SCALE;
                    setVal('rectW', w);
                    setVal('rectH', h);

                } else if (currentShape === 'circle') {
                    // Index 1 is the handle at (r, 0)
                    if (draggingVertexIndex === 1) {
                         const r = Math.sqrt(mouseRelX*mouseRelX + mouseRelY*mouseRelY) / PIXEL_SCALE;
                         setVal('circleR', r);
                    }

                } else if (currentShape === 'angle') {
                    // A=0(tip), O=1(vertex), B=2(base)
                    // Drag A: update len, angle
                    if (draggingVertexIndex === 2) {
                         const len = Math.sqrt(mouseRelX*mouseRelX + mouseRelY*mouseRelY) / PIXEL_SCALE;
                         let deg = Math.atan2(-mouseRelY, mouseRelX) * (180/Math.PI);
                         // Normalize for intuitive angle behavior (0 is right)
                         // Drawing logic: B = len * cos(-rad)
                         // atan2(-y, x) gives rad.
                         if(deg < 0) deg += 360;
                         setVal('angleLen', len);
                         setVal('angleSize', deg);
                    }

                } else if (currentShape === 'coords') {
                    // Update specific line in text area
                    const ta = document.getElementById('coordInput');
                    const lines = ta.value.split('\n');
                    if (lines[draggingVertexIndex]) {
                        // Convert screen Y (up is neg) back to math Y (up is pos)
                        const mathX = Math.round(mouseRelX / PIXEL_SCALE * 10) / 10;
                        const mathY = Math.round(-mouseRelY / PIXEL_SCALE * 10) / 10;
                        lines[draggingVertexIndex] = `${mathX}, ${mathY}`;
                        ta.value = lines.join('\n');
                    }
                }

                updateCanvas();

            } else if (isDragging) {
                // Pan Logic
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;
                offset.x += dx;
                offset.y += dy;
                dragStart = pos;
                updateCanvas();
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            isDraggingVertex = false;
            draggingVertexIndex = -1;
            canvas.style.cursor = 'default';
        });

        function resetView() {
            offset = { x: canvas.width / 2, y: canvas.height / 2 };
            updateCanvas();
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `figure-${currentShape}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Initialize
        updateUI();

    </script>
</body>
</html>